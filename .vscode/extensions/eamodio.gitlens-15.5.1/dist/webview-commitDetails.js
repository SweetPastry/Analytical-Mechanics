exports.id=0,exports.ids=[0,53],exports.modules={3915:(e,t,i)=>{i.r(t),i.d(t,{AIProviderService:()=>AIProviderService,extractDraftMessage:()=>W,getApiKey:()=>H,getMaxCharacters:()=>I});var n=i(1398),s=i(8803),a=i(5287),o=i(5313),r=i(9634),l=i(1391),c=i(7899),h=i(2471);async function d(e,t){let i;let s=await (await e.ai)?.getModels()??[],a=[];for(let e of s){if(e.hidden)continue;i!==e.provider.id&&(i=e.provider.id,a.push({label:e.provider.name,kind:n.QuickPickItemKind.Separator}));let s=e.provider.id===t?.provider&&e.id===t?.model;a.push({label:e.name,iconPath:new n.ThemeIcon(s?"check":"blank"),model:e,picked:s})}let o=n.window.createQuickPick();o.ignoreFocusOut=(0,h.dW)();let r=[],d={iconPath:new n.ThemeIcon("clear-all"),tooltip:"Reset AI Keys..."};try{return await new Promise(e=>{r.push(o.onDidHide(()=>e(void 0)),o.onDidAccept(()=>{0!==o.activeItems.length&&e(o.activeItems[0])}),o.onDidTriggerButton(e=>{e===d&&(0,c.RS)(l.T.ResetAIKey)})),o.title="Choose AI Model",o.placeholder="Select an AI model to use for experimental AI features",o.matchOnDescription=!0,o.matchOnDetail=!0,o.buttons=[d],o.items=a,o.show()})}finally{o.dispose(),r.forEach(e=>void e.dispose())}}var u=i(4832),p=i(3131),g=i(3459),m=i(4026);let f=`You are an advanced AI programming assistant tasked with summarizing code changes into a concise and meaningful commit message. Compose a commit message that:
- Strictly synthesizes meaningful information from the provided code diff
- Utilizes any additional user-provided context to comprehend the rationale behind the code changes
- Is clear and brief, with an informal yet professional tone, and without superfluous descriptions
- Avoids unnecessary phrases such as "this commit", "this change", and the like
- Avoids direct mention of specific code identifiers, names, or file names, unless they are crucial for understanding the purpose of the changes
- Most importantly emphasizes the 'why' of the change, its benefits, or the problem it addresses rather than only the 'what' that changed

Follow the user's instructions carefully, don't repeat yourself, don't include the code in the output, or make anything up!`,w=`You are an advanced AI programming assistant tasked with summarizing code changes into a concise and meaningful title with an optional description. Compose a title with an optional description that:
- Strictly synthesizes meaningful information from the provided code diff
- Utilizes any additional user-provided context to comprehend the rationale behind the code changes
- Is clear and brief, with an informal yet professional tone, and without superfluous descriptions
- Avoids unnecessary phrases such as "this commit", "this change", and the like
- Avoids direct mention of specific code identifiers, names, or file names, unless they are crucial for understanding the purpose of the changes
- Most importantly emphasizes the 'why' of the change, its benefits, or the problem it addresses rather than only the 'what' that changed

Follow the user's instructions carefully, don't repeat yourself, don't include the code in the output, or make anything up!`,y=`You are an advanced AI programming assistant tasked with summarizing code changes into a concise and meaningful code review title with an optional description. Compose a code review title with an optional description that:
- Strictly synthesizes meaningful information from the provided code diff
- Utilizes any additional user-provided context to comprehend the rationale behind the code changes
- Is clear and brief, with an informal yet professional tone, and without superfluous descriptions
- Avoids unnecessary phrases such as "this commit", "this change", and the like
- Avoids direct mention of specific code identifiers, names, or file names, unless they are crucial for understanding the purpose of the changes
- Most importantly emphasizes the 'why' of the change, its benefits, or the problem it addresses rather than only the 'what' that changed

Follow the user's instructions carefully, don't repeat yourself, don't include the code in the output, or make anything up!`,v={id:"anthropic",name:"Anthropic"};function x(e){return"claude-instant-1"===e.id||"claude-2"===e.id}let b=[{id:"claude-3-opus-20240229",name:"Claude 3 Opus",maxTokens:2e5,provider:v},{id:"claude-3-5-sonnet-20240620",name:"Claude 3.5 Sonnet",maxTokens:2e5,provider:v},{id:"claude-3-sonnet-20240229",name:"Claude 3 Sonnet",maxTokens:2e5,provider:v},{id:"claude-3-haiku-20240307",name:"Claude 3 Haiku",maxTokens:2e5,provider:v,default:!0},{id:"claude-2.1",name:"Claude 2.1",maxTokens:2e5,provider:v},{id:"claude-2",name:"Claude 2.0",maxTokens:1e5,provider:v},{id:"claude-instant-1",name:"Claude Instant",maxTokens:1e5,provider:v}];let AnthropicProvider=class AnthropicProvider{constructor(e){this.container=e}id=v.id;name=v.name;dispose(){}getModels(){return Promise.resolve(b)}async generateMessage(e,t,i,s,a){let o=await k(this.container.storage);if(null!=o)try{let r,l;return x(e)?[r,l]=await this.makeLegacyRequest(e,o,(e,n)=>{let o=t.substring(0,e),r=`

Human: ${s.systemPrompt}

Human: Here is the code diff to use to generate the ${s.contextName}:

${o}
`;return a?.context&&(r+=`
Human: Here is additional context which should be taken into account when generating the ${s.contextName}:

${a.context}
`),s.customPrompt&&(r+=`
Human: ${s.customPrompt}
`),r+="\nAssistant:",i["retry.count"]=n,i["input.length"]=(i["input.length"]??0)+r.length,r},4096,a?.cancellation):[r,l]=await this.makeRequest(e,o,s.systemPrompt,(e,n)=>{let o=t.substring(0,e),r=[{role:"user",content:[{type:"text",text:`Here is the code diff to use to generate the ${s.contextName}:`},{type:"text",text:o},...a?.context?[{type:"text",text:`Here is additional context which should be taken into account when generating the ${s.contextName}:`},{type:"text",text:a.context}]:[],...s.customPrompt?[{type:"text",text:s.customPrompt}]:[]]}];return i["retry.count"]=n,i["input.length"]=(i["input.length"]??0)+(0,m.cz)(r,e=>(0,m.cz)(e.content,e=>"text"===e.type?e.text.length:0)),r},4096,a?.cancellation),t.length>l&&n.window.showWarningMessage(`The diff of the changes had to be truncated to ${l} characters to fit within the Anthropic's limits.`),r}catch(e){throw Error(`Unable to generate ${s.contextName}: ${e.message}`)}}async generateDraftMessage(e,t,i,n){let s=n?.codeSuggestion===!0?u.H.get("experimental.generateCodeSuggestionMessagePrompt"):u.H.get("experimental.generateCloudPatchMessagePrompt");return s.endsWith(".")||(s+="."),this.generateMessage(e,t,i,{systemPrompt:n?.codeSuggestion===!0?y:w,customPrompt:s,contextName:n?.codeSuggestion===!0?"code suggestion title and description":"cloud patch title and description"},n)}async generateCommitMessage(e,t,i,n){let s=u.H.get("experimental.generateCommitMessagePrompt");return s.endsWith(".")||(s+="."),this.generateMessage(e,t,i,{systemPrompt:f,customPrompt:s,contextName:"commit message"},n)}async explainChanges(e,t,i,s,a){let o=await k(this.container.storage);if(null==o)return;let r=`You are an advanced AI programming assistant tasked with summarizing code changes into an explanation that is both easy to understand and meaningful. Construct an explanation that:
- Concisely synthesizes meaningful information from the provided code diff
- Incorporates any additional context provided by the user to understand the rationale behind the code changes
- Places the emphasis on the 'why' of the change, clarifying its benefits or addressing the problem that necessitated the change, beyond just detailing the 'what' has changed

Do not make any assumptions or invent details that are not supported by the code diff or the user-provided context.`;try{let l,c;return x(e)?[l,c]=await this.makeLegacyRequest(e,o,(e,n)=>{let a=i.substring(0,e),o=`

Human: ${r}

Human: Here is additional context provided by the author of the changes, which should provide some explanation to why these changes where made. Please strongly consider this information when generating your explanation:

${t}

Human: Now, kindly explain the following code diff in a way that would be clear to someone reviewing or trying to understand these changes:

${a}

Human: Remember to frame your explanation in a way that is suitable for a reviewer to quickly grasp the essence of the changes, the issues they resolve, and their implications on the codebase. And please don't explain how you arrived at the explanation, just provide the explanation.
Assistant:`;return s["retry.count"]=n,s["input.length"]=(s["input.length"]??0)+o.length,o},4096,a?.cancellation):[l,c]=await this.makeRequest(e,o,r,(e,n)=>{let a=i.substring(0,e),o=[{role:"user",content:[{type:"text",text:"Here is additional context provided by the author of the changes, which should provide some explanation to why these changes where made. Please strongly consider this information when generating your explanation:"},{type:"text",text:t},{type:"text",text:"Now, kindly explain the following code diff in a way that would be clear to someone reviewing or trying to understand these changes:"},{type:"text",text:a},{type:"text",text:"Remember to frame your explanation in a way that is suitable for a reviewer to quickly grasp the essence of the changes, the issues they resolve, and their implications on the codebase. And please don't explain how you arrived at the explanation, just provide the explanation"}]}];return s["retry.count"]=n,s["input.length"]=(s["input.length"]??0)+(0,m.cz)(o,e=>(0,m.cz)(e.content,e=>"text"===e.type?e.text.length:0)),o},4096,a?.cancellation),i.length>c&&n.window.showWarningMessage(`The diff of the changes had to be truncated to ${c} characters to fit within the Anthropic's limits.`),l}catch(e){throw Error(`Unable to explain changes: ${e.message}`)}}async fetch(e,t,i,n){let a;null!=n&&(a=new AbortController,n.onCancellationRequested(()=>a?.abort()));try{return await (0,g.hd)(x(e)?"https://api.anthropic.com/v1/complete":"https://api.anthropic.com/v1/messages",{headers:{Accept:"application/json",Authorization:`Bearer ${t}`,"Content-Type":"application/json","X-API-Key":t,"anthropic-version":"2023-06-01"},method:"POST",body:JSON.stringify(i)})}catch(e){if("AbortError"===e.name)throw new s.AL(e);throw e}}async makeRequest(e,t,i,n,s,a){let o=0,r=I(e,2600);for(;;){let l={model:e.id,messages:n(r,o),system:i,stream:!1,max_tokens:s},c=await this.fetch(e,t,l,a);if(!c.ok){let e;try{e=await c.json()}catch{}if(o++<2&&e?.error?.type==="invalid_request_error"&&e?.error?.message?.includes("prompt is too long")){r-=500*o;continue}throw Error(`(${this.name}:${c.status}) ${e?.error?.message||c.statusText})`)}return[(await c.json()).content.map(e=>e.text).join("\n").trim(),r]}}async makeLegacyRequest(e,t,i,n,s){let a=0,o=I(e,2600);for(;;){let r={model:e.id,prompt:i(o,a),stream:!1,max_tokens_to_sample:n},l=await this.fetch(e,t,r,s);if(!l.ok){let e;try{e=await l.json()}catch{}if(a++<2&&e?.error?.type==="invalid_request_error"&&e?.error?.message?.includes("prompt is too long")){o-=500*a;continue}throw Error(`(${this.name}:${l.status}) ${e?.error?.message||l.statusText})`)}return[(await l.json()).completion.trim(),o]}}};async function k(e){return H(e,{id:v.id,name:v.name,validator:e=>/(?:sk-)?[a-zA-Z0-9-_]{32,}/.test(e),url:"https://console.anthropic.com/account/keys"})}let C={id:"gemini",name:"Google"},_=[{id:"gemini-1.5-pro-latest",name:"Gemini 1.5 Pro",maxTokens:1048576,provider:C,default:!0},{id:"gemini-1.5-flash-latest",name:"Gemini 1.5 Flash",maxTokens:1048576,provider:C},{id:"gemini-1.0-pro",name:"Gemini 1.0 Pro",maxTokens:30720,provider:C}];let GeminiProvider=class GeminiProvider{constructor(e){this.container=e}id=C.id;name=C.name;dispose(){}getModels(){return Promise.resolve(_)}async generateMessage(e,t,i,s,a){let o=await S(this.container.storage);if(null==o)return;let r=I(e,2600);for(;;){let l=t.substring(0,r),c={systemInstruction:{parts:[{text:s.systemPrompt}]},contents:[{role:"user",parts:[{text:`Here is the code diff to use to generate the ${s.contextName}:

${l}`},...a?.context?[{text:`Here is additional context which should be taken into account when generating the ${s.contextName}:

${a.context}`}]:[],{text:s.customPrompt}]}]};i["retry.count"]=0,i["input.length"]=(i["input.length"]??0)+(0,m.cz)(c.systemInstruction?.parts,e=>e.text.length)+(0,m.cz)(c.contents,e=>(0,m.cz)(e.parts,e=>e.text.length));let h=await this.fetch(e.id,o,c,a?.cancellation);if(!h.ok){let e;try{e=await h.json()}catch{}throw Error(`Unable to generate ${s.contextName}: (${this.name}:${h.status}) ${e?.error?.message||h.statusText}`)}return t.length>r&&n.window.showWarningMessage(`The diff of the changes had to be truncated to ${r} characters to fit within the Gemini's limits.`),(await h.json()).candidates[0].content.parts[0].text.trim()}}async generateDraftMessage(e,t,i,n){let s=n?.codeSuggestion===!0?u.H.get("experimental.generateCodeSuggestionMessagePrompt"):u.H.get("experimental.generateCloudPatchMessagePrompt");return s.endsWith(".")||(s+="."),this.generateMessage(e,t,i,{systemPrompt:n?.codeSuggestion===!0?y:w,customPrompt:s,contextName:n?.codeSuggestion===!0?"code suggestion title and description":"cloud patch title and description"},n)}async generateCommitMessage(e,t,i,n){let s=u.H.get("experimental.generateCommitMessagePrompt");return s.endsWith(".")||(s+="."),this.generateMessage(e,t,i,{systemPrompt:f,customPrompt:s,contextName:"commit message"},n)}async explainChanges(e,t,i,s,a){let o=await S(this.container.storage);if(null==o)return;let r=I(e,3e3);for(;;){let l=i.substring(0,r),c={systemInstruction:{parts:[{text:`You are an advanced AI programming assistant tasked with summarizing code changes into an explanation that is both easy to understand and meaningful. Construct an explanation that:
- Concisely synthesizes meaningful information from the provided code diff
- Incorporates any additional context provided by the user to understand the rationale behind the code changes
- Places the emphasis on the 'why' of the change, clarifying its benefits or addressing the problem that necessitated the change, beyond just detailing the 'what' has changed

Do not make any assumptions or invent details that are not supported by the code diff or the user-provided context.`}]},contents:[{role:"user",parts:[{text:`Here is additional context provided by the author of the changes, which should provide some explanation to why these changes where made. Please strongly consider this information when generating your explanation:

${t}`},{text:`Now, kindly explain the following code diff in a way that would be clear to someone reviewing or trying to understand these changes:

${l}`},{text:"Remember to frame your explanation in a way that is suitable for a reviewer to quickly grasp the essence of the changes, the issues they resolve, and their implications on the codebase."}]}]};s["retry.count"]=0,s["input.length"]=(s["input.length"]??0)+(0,m.cz)(c.systemInstruction?.parts,e=>e.text.length)+(0,m.cz)(c.contents,e=>(0,m.cz)(e.parts,e=>e.text.length));let h=await this.fetch(e.id,o,c,a?.cancellation);if(!h.ok){let e;try{e=await h.json()}catch{}throw Error(`Unable to explain changes: (${this.name}:${h.status}) ${e?.error?.message||h.statusText}`)}return i.length>r&&n.window.showWarningMessage(`The diff of the changes had to be truncated to ${r} characters to fit within the Gemini's limits.`),(await h.json()).candidates[0].content.parts[0].text.trim()}}async fetch(e,t,i,n){let a;null!=n&&(a=new AbortController,n.onCancellationRequested(()=>a?.abort()));try{return await (0,g.hd)(`https://generativelanguage.googleapis.com/v1beta/models/${e}:generateContent`,{headers:{Accept:"application/json","Content-Type":"application/json","x-goog-api-key":t},method:"POST",body:JSON.stringify(i),signal:a?.signal})}catch(e){if("AbortError"===e.name)throw new s.AL(e);throw e}}};async function S(e){return H(e,{id:C.id,name:C.name,validator:()=>!0,url:"https://aistudio.google.com/app/apikey"})}let P={id:"openai",name:"OpenAI"},R=[{id:"gpt-4o",name:"GPT-4 Omni",maxTokens:128e3,provider:P,default:!0},{id:"gpt-4o-mini",name:"GPT-4 Omni Mini",maxTokens:128e3,provider:P},{id:"gpt-4-turbo",name:"GPT-4 Turbo with Vision",maxTokens:128e3,provider:P},{id:"gpt-4-turbo-2024-04-09",name:"GPT-4 Turbo Preview (2024-04-09)",maxTokens:128e3,provider:P,hidden:!0},{id:"gpt-4-turbo-preview",name:"GPT-4 Turbo Preview",maxTokens:128e3,provider:P},{id:"gpt-4-0125-preview",name:"GPT-4 0125 Preview",maxTokens:128e3,provider:P,hidden:!0},{id:"gpt-4-1106-preview",name:"GPT-4 1106 Preview",maxTokens:128e3,provider:P,hidden:!0},{id:"gpt-4",name:"GPT-4",maxTokens:8192,provider:P},{id:"gpt-4-0613",name:"GPT-4 0613",maxTokens:8192,provider:P,hidden:!0},{id:"gpt-4-32k",name:"GPT-4 32k",maxTokens:32768,provider:P},{id:"gpt-4-32k-0613",name:"GPT-4 32k 0613",maxTokens:32768,provider:P,hidden:!0},{id:"gpt-3.5-turbo",name:"GPT-3.5 Turbo",maxTokens:16385,provider:P},{id:"gpt-3.5-turbo-0125",name:"GPT-3.5 Turbo 0125",maxTokens:16385,provider:P,hidden:!0},{id:"gpt-3.5-turbo-1106",name:"GPT-3.5 Turbo 1106",maxTokens:16385,provider:P,hidden:!0},{id:"gpt-3.5-turbo-16k",name:"GPT-3.5 Turbo 16k",maxTokens:16385,provider:P,hidden:!0}];let OpenAIProvider=class OpenAIProvider{constructor(e){this.container=e}id=P.id;name=P.name;dispose(){}getModels(){return Promise.resolve(R)}get url(){return u.H.get("ai.experimental.openai.url")||"https://api.openai.com/v1/chat/completions"}async generateMessage(e,t,i,s,a){let o=await T(this.container.storage);if(null==o)return;let r=0,l=I(e,2600);for(;;){let c=t.substring(0,l),h={model:e.id,messages:[{role:"system",content:s.systemPrompt},{role:"user",content:`Here is the code diff to use to generate the ${s.contextName}:

${c}`},...a?.context?[{role:"user",content:`Here is additional context which should be taken into account when generating the ${s.contextName}:

${a.context}`}]:[],{role:"user",content:s.customPrompt}]};i["retry.count"]=r,i["input.length"]=(i["input.length"]??0)+(0,m.cz)(h.messages,e=>e.content.length);let d=await this.fetch(o,h,a?.cancellation);if(!d.ok){let t;if(404===d.status)throw Error(`Unable to generate ${s.contextName}: Your API key doesn't seem to have access to the selected '${e.id}' model`);if(429===d.status)throw Error(`Unable to generate ${s.contextName}: (${this.name}:${d.status}) Too many requests (rate limit exceeded) or your API key is associated with an expired trial`);try{t=await d.json()}catch{}if(r++<2&&t?.error?.code==="context_length_exceeded"){l-=500*r;continue}throw Error(`Unable to generate ${s.contextName}: (${this.name}:${d.status}) ${t?.error?.message||d.statusText}`)}return t.length>l&&n.window.showWarningMessage(`The diff of the changes had to be truncated to ${l} characters to fit within the OpenAI's limits.`),(await d.json()).choices[0].message.content.trim()}}async generateDraftMessage(e,t,i,n){let s=n?.codeSuggestion===!0?u.H.get("experimental.generateCodeSuggestionMessagePrompt"):u.H.get("experimental.generateCloudPatchMessagePrompt");return s.endsWith(".")||(s+="."),this.generateMessage(e,t,i,{systemPrompt:n?.codeSuggestion===!0?y:w,customPrompt:s,contextName:n?.codeSuggestion===!0?"code suggestion title and description":"cloud patch title and description"},n)}async generateCommitMessage(e,t,i,n){let s=u.H.get("experimental.generateCommitMessagePrompt");return s.endsWith(".")||(s+="."),this.generateMessage(e,t,i,{systemPrompt:f,customPrompt:s,contextName:"commit message"},n)}async explainChanges(e,t,i,s,a){let o=await T(this.container.storage);if(null==o)return;let r=0,l=I(e,3e3);for(;;){let c=i.substring(0,l),h={model:e.id,messages:[{role:"system",content:`You are an advanced AI programming assistant tasked with summarizing code changes into an explanation that is both easy to understand and meaningful. Construct an explanation that:
- Concisely synthesizes meaningful information from the provided code diff
- Incorporates any additional context provided by the user to understand the rationale behind the code changes
- Places the emphasis on the 'why' of the change, clarifying its benefits or addressing the problem that necessitated the change, beyond just detailing the 'what' has changed

Do not make any assumptions or invent details that are not supported by the code diff or the user-provided context.`},{role:"user",content:`Here is additional context provided by the author of the changes, which should provide some explanation to why these changes where made. Please strongly consider this information when generating your explanation:

${t}`},{role:"user",content:`Now, kindly explain the following code diff in a way that would be clear to someone reviewing or trying to understand these changes:

${c}`},{role:"user",content:"Remember to frame your explanation in a way that is suitable for a reviewer to quickly grasp the essence of the changes, the issues they resolve, and their implications on the codebase."}]};s["retry.count"]=r,s["input.length"]=(s["input.length"]??0)+(0,m.cz)(h.messages,e=>e.content.length);let d=await this.fetch(o,h,a?.cancellation);if(!d.ok){let t;if(404===d.status)throw Error(`Unable to explain changes: Your API key doesn't seem to have access to the selected '${e.id}' model`);if(429===d.status)throw Error(`Unable to explain changes: (${this.name}:${d.status}) Too many requests (rate limit exceeded) or your API key is associated with an expired trial`);try{t=await d.json()}catch{}if(r++<2&&t?.error?.code==="context_length_exceeded"){l-=500*r;continue}throw Error(`Unable to explain changes: (${this.name}:${d.status}) ${t?.error?.message||d.statusText}`)}return i.length>l&&n.window.showWarningMessage(`The diff of the changes had to be truncated to ${l} characters to fit within the OpenAI's limits.`),(await d.json()).choices[0].message.content.trim()}}async fetch(e,t,i){let n;let a=this.url,o=a.includes(".azure.com");null!=i&&(n=new AbortController,i.onCancellationRequested(()=>n?.abort()));try{return(0,g.hd)(a,{headers:{Accept:"application/json","Content-Type":"application/json",...o?{"api-key":e}:{Authorization:`Bearer ${e}`}},method:"POST",body:JSON.stringify(t),signal:n?.signal})}catch(e){if("AbortError"===e.name)throw new s.AL(e);throw e}}};async function T(e){return H(e,{id:P.id,name:P.name,validator:e=>/(?:sk-)?[a-zA-Z0-9]{32,}/.test(e),url:"https://platform.openai.com/account/api-keys"})}var M=i(3166);let D={id:"vscode",name:"VS Code Provided"};let VSCodeAIProvider=class VSCodeAIProvider{constructor(e){this.container=e}id=D.id;_name;get name(){return this._name??D.name}dispose(){}async getModels(){return(await n.lm.selectChatModels()).map(A)}async getChatModel(e){let t=await n.lm.selectChatModels(e.selector);return t?.[0]}async generateMessage(e,t,i,s,a){let o,r;let l=await this.getChatModel(e);if(null==l)return;o=a?.cancellation==null?(r=new n.CancellationTokenSource).token:a.cancellation;let c=0,h=I(e,2600)-1e3;try{for(;;){let r=t.substring(0,h),d=[n.LanguageModelChatMessage.User(s.systemPrompt),n.LanguageModelChatMessage.User(`Here is the code diff to use to generate the ${s.contextName}:

${r}`),...a?.context?[n.LanguageModelChatMessage.User(`Here is additional context which should be taken into account when generating the ${s.contextName}:

${a.context}`)]:[],n.LanguageModelChatMessage.User(s.customPrompt)];i["retry.count"]=c,i["input.length"]=(i["input.length"]??0)+(0,m.cz)(d,e=>e.content.length);try{let i=await l.sendRequest(d,{},o);t.length>h&&n.window.showWarningMessage(`The diff of the changes had to be truncated to ${h} characters to fit within ${$(e.provider.name)} limits.`);let s="";for await(let e of i.text)s+=e;return s.trim()}catch(i){let t=i instanceof Error?i.message:String(i);if(i instanceof Error&&"cause"in i&&i.cause instanceof Error&&(t+=`
${i.cause.message}`,c++<2&&i.cause.message.includes("exceeds token limit"))){h-=500*c;continue}throw Error(`Unable to generate commit message: (${$(e.provider.name)}:${i.code}) ${t}`)}}}finally{r?.dispose()}}async generateDraftMessage(e,t,i,n){let s=n?.codeSuggestion===!0?u.H.get("experimental.generateCodeSuggestionMessagePrompt"):u.H.get("experimental.generateCloudPatchMessagePrompt");return s.endsWith(".")||(s+="."),this.generateMessage(e,t,i,{systemPrompt:n?.codeSuggestion===!0?y:w,customPrompt:s,contextName:n?.codeSuggestion===!0?"code suggestion title and description":"cloud patch title and description"},null!=n?{cancellation:n.cancellation,context:n.context}:void 0)}async generateCommitMessage(e,t,i,n){let s=u.H.get("experimental.generateCommitMessagePrompt");return s.endsWith(".")||(s+="."),this.generateMessage(e,t,i,{systemPrompt:f,customPrompt:s,contextName:"commit message"},n)}async explainChanges(e,t,i,s,a){let o,r;let l=await this.getChatModel(e);if(null==l)return;o=a?.cancellation==null?(r=new n.CancellationTokenSource).token:a.cancellation;let c=0,h=I(e,3e3)-1e3;try{for(;;){let a=i.substring(0,h),r=[n.LanguageModelChatMessage.User(`You are an advanced AI programming assistant tasked with summarizing code changes into an explanation that is both easy to understand and meaningful. Construct an explanation that:
- Concisely synthesizes meaningful information from the provided code diff
- Incorporates any additional context provided by the user to understand the rationale behind the code changes
- Places the emphasis on the 'why' of the change, clarifying its benefits or addressing the problem that necessitated the change, beyond just detailing the 'what' has changed

Do not make any assumptions or invent details that are not supported by the code diff or the user-provided context.`),n.LanguageModelChatMessage.User(`Here is additional context provided by the author of the changes, which should provide some explanation to why these changes where made. Please strongly consider this information when generating your explanation:

${t}`),n.LanguageModelChatMessage.User(`Now, kindly explain the following code diff in a way that would be clear to someone reviewing or trying to understand these changes:

${a}`),n.LanguageModelChatMessage.User("Remember to frame your explanation in a way that is suitable for a reviewer to quickly grasp the essence of the changes, the issues they resolve, and their implications on the codebase.")];s["retry.count"]=c,s["input.length"]=(s["input.length"]??0)+(0,m.cz)(r,e=>e.content.length);try{let t=await l.sendRequest(r,{},o);i.length>h&&n.window.showWarningMessage(`The diff of the changes had to be truncated to ${h} characters to fit within ${$(e.provider.name)} limits.`);let s="";for await(let e of t.text)s+=e;return s.trim()}catch(i){let t=i instanceof Error?i.message:String(i);if(i instanceof Error&&"cause"in i&&i.cause instanceof Error&&(t+=`
${i.cause.message}`,c++<2&&i.cause.message.includes("exceeds token limit"))){h-=500*c;continue}throw Error(`Unable to explain changes: (${$(e.provider.name)}:${i.code}) ${t}`)}}}finally{r?.dispose()}}};function A(e){return{id:`${e.vendor}:${e.family}`,name:`${(0,M.ZH)(e.vendor)} ${e.name}`,vendor:e.vendor,selector:{vendor:e.vendor,family:e.family},maxTokens:e.maxInputTokens,provider:{id:D.id,name:(0,M.ZH)(e.vendor)}}}function $(e){return e.endsWith("s")?`${e}'`:`${e}'s`}let q=new Map([["openai",OpenAIProvider],["anthropic",AnthropicProvider],["gemini",GeminiProvider]]);(0,h.Av)("language-models")&&q.set("vscode",VSCodeAIProvider);let AIProviderService=class AIProviderService{constructor(e){this.container=e}_provider;_model;dispose(){this._provider?.dispose()}get currentProviderId(){return this._provider?.id}getConfiguredModel(){let e=u.H.get("ai.experimental.model")??void 0;if(null!=e){let[t,i]=e.split(":");if(null!=t&&this.supports(t)&&(null!=i||"vscode"===t&&null!=(i=u.H.get("ai.experimental.vscode.model"))&&/^(.+):(.+)$/.test(i)))return{provider:t,model:i}}}async getModels(){let e=[...q.values()].map(e=>new e(this.container));return(await Promise.allSettled(e.map(e=>e.getModels()))).flatMap(e=>(0,p.Ro)(e,[]))}async getModel(e){let t=this.getConfiguredModel();if(!e?.force&&t?.provider!=null&&t?.model!=null){let e=await this.getOrUpdateModel(t.provider,t.model);if(null!=e)return e}if(e?.silent)return;let i=await d(this.container,t);if(null!=i)return this.getOrUpdateModel(i.model)}async getOrUpdateModel(e,t){let i,n;i="string"==typeof e?e:(n=e).provider.id;let s=!1;if(i!==this._provider?.id){s=!0,this._provider?.dispose();let e=q.get(i);if(null==e){this._provider=void 0,this._model=void 0;return}this._provider=new e(this.container)}if(null==n){if(null!=t&&t===this._model?.id)n=this._model;else if(s=!0,null==(n=(await this._provider.getModels())?.find(e=>e.id===t))){this._model=void 0;return}}else n.id!==this._model?.id&&(s=!0);return s&&(n.provider.id===D.id?(await u.H.updateEffective("ai.experimental.model","vscode"),await u.H.updateEffective("ai.experimental.vscode.model",n.id)):await u.H.updateEffective("ai.experimental.model",`${n.provider.id}:${n.id}`)),this._model=n,n}async generateCommitMessage(e,t,i){let a=await this.getChanges(e);if(null==a)return;let o=await this.getModel();if(null==o)return;let r=this._provider,l={type:"commitMessage","model.id":o.id,"model.provider.id":o.provider.id,"model.provider.name":o.provider.name,"retry.count":0},c={source:t.source};if(!await E(o,this.container.storage)){this.container.telemetry.sendEvent("ai/generate",{...l,"failed.reason":"user-declined"},c);return}if(i?.cancellation?.isCancellationRequested){this.container.telemetry.sendEvent("ai/generate",{...l,"failed.reason":"user-cancelled"},c);return}let h=r.generateCommitMessage(o,a,l,{cancellation:i?.cancellation,context:i?.context}),d=Date.now();try{let e=await (i?.progress!=null?n.window.withProgress(i.progress,()=>h):h);return l["output.length"]=e?.length,this.container.telemetry.sendEvent("ai/generate",{...l,duration:Date.now()-d},c),e}catch(e){throw this.container.telemetry.sendEvent("ai/generate",{...l,duration:Date.now()-d,...e instanceof s.AL?{"failed.reason":"user-cancelled"}:{"failed.reason":"error","failed.error":String(e)}},c),e}}async generateDraftMessage(e,t,i){let a=await this.getChanges(e);if(null==a)return;let o=await this.getModel();if(null==o)return;let r=this._provider,l={type:"draftMessage",draftType:t.type,"model.id":o.id,"model.provider.id":o.provider.id,"model.provider.name":o.provider.name,"retry.count":0},c={source:t.source};if(!await E(o,this.container.storage)){this.container.telemetry.sendEvent("ai/generate",{...l,"failed.reason":"user-declined"},c);return}if(i?.cancellation?.isCancellationRequested){this.container.telemetry.sendEvent("ai/generate",{...l,"failed.reason":"user-cancelled"},c);return}let h=r.generateDraftMessage(o,a,l,{cancellation:i?.cancellation,context:i?.context,codeSuggestion:i?.codeSuggestion}),d=Date.now();try{let e=await (i?.progress!=null?n.window.withProgress(i.progress,()=>h):h);return l["output.length"]=e?.length,this.container.telemetry.sendEvent("ai/generate",{...l,duration:Date.now()-d},c),e}catch(e){throw this.container.telemetry.sendEvent("ai/generate",{...l,duration:Date.now()-d,...e instanceof s.AL?{"failed.reason":"user-cancelled"}:{"failed.reason":"error","failed.error":String(e)}},c),e}}async getChanges(e,t){let i;if(Array.isArray(e))i=e.join("\n");else{let n=(0,r.Z6)(e)?e:this.container.git.getRepository(e);if(null==n)throw Error("Unable to find repository");let s=await this.container.git.getDiff(n.uri,o.id);if(!s?.contents&&(s=await this.container.git.getDiff(n.uri,o.SU),!s?.contents))throw Error("No changes to generate a commit message from.");if(t?.cancellation?.isCancellationRequested)return;i=s.contents}return i}async explainCommit(e,t,i){let o=await this.container.git.getDiff(e.repoPath,e.ref);if(!o?.contents)throw Error("No changes found to explain.");let r=await this.getModel();if(null==r)return;let l=this._provider,c={type:"change",changeType:t.type,"model.id":r.id,"model.provider.id":r.provider.id,"model.provider.name":r.provider.name,"retry.count":0},h={source:t.source};if(!await E(r,this.container.storage)){this.container.telemetry.sendEvent("ai/explain",{...c,"failed.reason":"user-declined"},h);return}let d=(0,a.WM)(e)?e:await this.container.git.getCommit(e.repoPath,e.ref);if(null==d)throw Error("Unable to find commit");if(d.hasFullDetails()||(await d.ensureFullDetails(),(0,a.aQ)(d)),i?.cancellation?.isCancellationRequested){this.container.telemetry.sendEvent("ai/explain",{...c,"failed.reason":"user-cancelled"},h);return}let u=l.explainChanges(r,d.message,o.contents,c,{cancellation:i?.cancellation}),p=Date.now();try{let e=await (i?.progress!=null?n.window.withProgress(i.progress,()=>u):u);return c["output.length"]=e?.length,this.container.telemetry.sendEvent("ai/explain",{...c,duration:Date.now()-p},h),e}catch(e){throw this.container.telemetry.sendEvent("ai/explain",{...c,duration:Date.now()-p,...e instanceof s.AL?{"failed.reason":"user-cancelled"}:{"failed.reason":"error","failed.error":String(e)}},h),e}}async reset(e){let t,{_provider:i}=this;null==i&&(await this.getModel({silent:!0}),i=this._provider);let s={title:"Reset Current"},a={title:"Reset All"},o={title:"Cancel",isCloseAffordance:!0};if(t=e?a:null==i?await n.window.showInformationMessage("Do you want to reset all of the stored AI keys?",{modal:!0},a,o):await n.window.showInformationMessage(`Do you want to reset the stored key for the current provider (${i.name}) or reset all of the stored AI keys?`,{modal:!0},s,a,o),null!=i&&t===s)n.env.clipboard.writeText(await this.container.storage.getSecret(`gitlens.${i.id}.key`)??""),this.container.storage.deleteSecret(`gitlens.${i.id}.key`),this.container.storage.delete(`confirm:ai:tos:${i.id}`),this.container.storage.deleteWorkspace(`confirm:ai:tos:${i.id}`);else if(t===a){let e=[];for(let[t]of q)e.push(await this.container.storage.getSecret(`gitlens.${t}.key`));for(let[t]of(n.env.clipboard.writeText(e.join("\n")),q))this.container.storage.deleteSecret(`gitlens.${t}.key`);this.container.storage.deleteWithPrefix("confirm:ai:tos"),this.container.storage.deleteWorkspaceWithPrefix("confirm:ai:tos")}}supports(e){return q.has(e)}async switchModel(){await this.getModel({force:!0})}};async function E(e,t){if(t.get(`confirm:ai:tos:${e.provider.id}`,!1)||t.getWorkspace(`confirm:ai:tos:${e.provider.id}`,!1))return!0;let i={title:"Continue"},s={title:"Always for this Workspace"},a={title:"Always"},o=await n.window.showInformationMessage(`GitLens experimental AI features require sending a diff of the code changes to ${e.provider.name} for analysis. This may contain sensitive information.

Do you want to continue?`,{modal:!0},i,s,a,{title:"Cancel",isCloseAffordance:!0});return o===i||(o===s?(t.storeWorkspace(`confirm:ai:tos:${e.provider.id}`,!0),!0):o===a&&(t.store(`confirm:ai:tos:${e.provider.id}`,!0),!0))}function I(e,t){let i=3.1*e.maxTokens-t/3.1;return Math.floor(i-.1*i)}async function H(e,t){let i=await e.getSecret(`gitlens.${t.id}.key`);if(!i){let s=n.window.createInputBox();s.ignoreFocusOut=!0;let a=[];try{let e={iconPath:new n.ThemeIcon("link-external"),tooltip:`Open the ${t.name} API Key Page`};i=await new Promise(i=>{a.push(s.onDidHide(()=>i(void 0)),s.onDidChangeValue(e=>{if(e&&!t.validator(e)){s.validationMessage=`Please enter a valid ${t.name} API key`;return}s.validationMessage=void 0}),s.onDidAccept(()=>{let e=s.value.trim();if(!e||!t.validator(e)){s.validationMessage=`Please enter a valid ${t.name} API key`;return}i(e)}),s.onDidTriggerButton(i=>{i===e&&n.env.openExternal(n.Uri.parse(t.url))})),s.password=!0,s.title=`Connect to ${t.name}`,s.placeholder=`Please enter your ${t.name} API key to use this feature`,s.prompt=`Enter your [${t.name} API Key](${t.url} "Get your ${t.name} API key")`,s.buttons=[e],s.show()})}finally{s.dispose(),a.forEach(e=>void e.dispose())}if(!i)return;e.storeSecret(`gitlens.${t.id}.key`,i)}return i}function W(e,t="\n\n"){let i=e.indexOf(t)??0;return{title:i>-1?e.substring(0,i):e,description:i>-1?e.substring(i+t.length):void 0}}},1112:(e,t,i)=>{i.d(t,{l:()=>s});var n=i(1398);function s(e){if(null!=e)try{return JSON.parse(JSON.stringify(e,function(e,t){if(t instanceof Date)return t.getTime();if(t instanceof Map||t instanceof Set)return[...t.entries()];if(t instanceof Function||t instanceof Error)return;if(t instanceof RegExp||t instanceof n.Uri)return t.toString();let i=this[e];return i instanceof Date?i.getTime():i instanceof n.Uri?i.toString():t}))}catch(e){throw e}}},8299:(e,t,i)=>{i.d(t,{CommitDetailsWebviewProvider:()=>CommitDetailsWebviewProvider});var n=i(910),s=i(1398),a=i(3915),o=i(9659),r=i(5176),l=i(1391),c=i(6090),h=i(9432),d=i(3161),u=i(236),p=i(5287),g=i(5313),m=i(8559),f=i(304),w=i(6645),y=i(9634),v=i(103),x=i(1298),b=i(7463),k=i(1014),C=i(7899),_=i(4832),S=i(8973),P=i(6707),R=i(560),T=i(4026),M=i(3916),D=i(3446);let MRU=class MRU{constructor(e=10,t){this.maxSize=e,this.comparator=t}stack=[];get count(){return this.stack.length}_position=0;get position(){return this._position}add(e){this._position>0&&(this.stack.splice(0,this._position),this._position=0);let t=null!=this.comparator?this.stack.findIndex(t=>this.comparator(e,t)):this.stack.indexOf(e);-1!==t?this.stack.splice(t,1):this.stack.length===this.maxSize&&this.stack.pop(),this.stack.unshift(e),this._position=0}get(e){if(null!=e){if(e<0||e>=this.stack.length)return;return this.stack[e]}return this.stack.length>0?this.stack[0]:void 0}insert(e){this._position>0&&(this.stack.splice(0,this._position),this._position=0),this.stack.unshift(e),this._position++}navigate(e){if(!(this.stack.length<=1)){if("back"===e){if(this._position>=this.stack.length-1)return;this._position+=1}else{if(this._position<=0)return;this._position-=1}return this.stack[this._position]}}};var A=i(3131),$=i(1112),q=i(7565),E=i(1500),I=i(3355);let H="commitDetails",W=new I.Q2(H,"commit/suggestChanges"),F=new I.Q2(H,"commit/actions/execute"),O=new I.Q2(H,"file/actions/execute"),z=new I.Q2(H,"file/open"),U=new I.Q2(H,"file/openOnRemote"),N=new I.Q2(H,"file/compareWorking"),L=new I.Q2(H,"file/comparePrevious"),j=new I.Q2(H,"file/stage"),G=new I.Q2(H,"file/unstage"),Q=new I.Q2(H,"pickCommit"),V=new I.Q2(H,"searchCommit"),J=new I.Q2(H,"switchMode");new I.Q2(H,"autolinkSettings");let B=new I.Q2(H,"pin"),Y=new I.Q2(H,"navigate"),K=new I.Q2(H,"preferences/update"),Z=new I.Q2(H,"wip/createPatch"),X=new I.Q2(H,"wip/changeReviewMode"),ee=new I.Q2(H,"wip/showCodeSuggestion"),et=new I.Q2(H,"fetch"),ei=new I.Q2(H,"publish"),en=new I.Q2(H,"push"),es=new I.Q2(H,"pull"),ea=new I.Q2(H,"switch"),eo=new I.Q2(H,"openPullRequestChanges"),er=new I.Q2(H,"openPullRequestComparison"),el=new I.Q2(H,"openPullRequestOnRemote"),ec=new I.Q2(H,"openPullRequestDetails"),eh=new I.Oz(H,"explain"),ed=new I.Oz(H,"generate"),eu=new I.C1(H,"didChange",!0),ep=new I.C1(H,"didChange/wip");new I.C1(H,"org/settings/didChange");let eg=new I.C1(H,"didChange/jira"),em=new I.C1(H,"didChange/account"),ef=new I.C1(H,"didChange/patch");var ew=Object.defineProperty,ey=Object.getOwnPropertyDescriptor,ev=(e,t,i,n)=>{for(var s,a=n>1?void 0:n?ey(t,i):t,o=e.length-1;o>=0;o--)(s=e[o])&&(a=(n?s(t,i,a):s(a))||a);return n&&a&&ew(t,i,a),a};let CommitDetailsWebviewProvider=class CommitDetailsWebviewProvider{constructor(e,t,i){this.container=e,this.host=t,this.options=i,this._context={mode:"commit",inReview:!1,navigationStack:{count:0,position:0},pinned:!1,preferences:this.getPreferences(),commit:void 0,richStateLoaded:!1,formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:void 0,orgSettings:this.getOrgSettings(),hasConnectedJira:void 0,hasAccount:void 0},this._disposable=s.Disposable.from(_.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,S.wt)(this.onContextChanged,this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),e.integrations.onDidChangeConnectionState(this.onIntegrationConnectionStateChanged,this))}_bootstraping=!0;_context;_pendingContext;_disposable;_pinned=!1;_focused=!1;_commitStack=new MRU(10,(e,t)=>e.ref===t.ref);dispose(){this._disposable.dispose(),this._lineTrackerDisposable?.dispose(),this._repositorySubscription?.subscription.dispose(),this._selectionTrackerDisposable?.dispose(),this._wipSubscription?.subscription.dispose()}_skipNextRefreshOnVisibilityChange=!1;_shouldRefreshPullRequestDetails=!1;async onShowing(e,t,...i){let[n]=i;return n?.type==="wip"?this.onShowingWip(n):this.onShowingCommit(n,t)}get inReview(){return this._pendingContext?.inReview??this._context.inReview}async onShowingWip(e,t){this.updatePendingContext({source:e.source});let i=null!=e.inReview&&this.inReview!=e.inReview;return"wip"!=this.mode||null!=e.repository&&this._context.wip?.repo!=e.repository?(i&&this.updatePendingContext({inReview:e.inReview}),await this.setMode("wip",e.repository),i&&!0===e.inReview&&this.trackOpenReviewMode(e.source)):i&&await this.setInReview(e.inReview,e.source),(!t?.preserveVisibility||!!this.host.visible)&&("launchpad"===e.source&&this.host.visible&&(this._shouldRefreshPullRequestDetails=!0,this.onRefresh()),!0)}async onShowingCommit(e,t){let i,n;if((0,E.c)(e)){let{commit:t}=e.state;t?.repoPath!=null&&t?.sha!=null&&(i=null!=t.stashNumber?{commit:(0,w.kA)(t.sha,t.repoPath,{refType:"stash",name:t.message,number:t.stashNumber})}:{commit:(0,w.kA)(t.sha,t.repoPath,{refType:"revision",message:t.message})})}else i=null!=e&&"object"==typeof e?e:void 0;return null!=i&&(i.preserveFocus&&(null==t?t={preserveFocus:!0}:t.preserveFocus=!0),{commit:n,...i}=i),null!=n&&"wip"===this.mode&&i?.interaction!=="passive"&&await this.setMode("commit"),null!=n||this._pinned||(n=this.getBestCommitOrStash()),null==n||this._context.commit?.ref.startsWith(n.ref)||await this.updateCommit(n,{pinned:!1}),(!i?.preserveVisibility||!!this.host.visible)&&(this._skipNextRefreshOnVisibilityChange=!0,!0)}async trackOpenReviewMode(e){if(this._context.wip?.pullRequest==null)return;let t=this._context.wip.pullRequest.provider.id,i=await this.container.git.visibility(this._context.wip.repo.path),n=this._context.wip.changes?.files.length??0;this.container.telemetry.sendEvent("openReviewMode",{provider:t,"repository.visibility":i,repoPrivacy:i,source:e??"inspect",filesChanged:n})}includeBootstrap(){return this._bootstraping=!0,this._context={...this._context,...this._pendingContext},this._pendingContext=void 0,this.getState(this._context)}registerCommands(){return[(0,C.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0))]}onFocusChanged(e){this._focused!==e&&(this._focused=e,e&&this.isLineTrackerSuspended&&this.ensureTrackers())}onMessageReceived(e){switch(!0){case U.is(e):this.openFileOnRemote(e.params);break;case z.is(e):this.openFile(e.params);break;case N.is(e):this.openFileComparisonWithWorking(e.params);break;case L.is(e):this.openFileComparisonWithPrevious(e.params);break;case O.is(e):this.showFileActions(e.params);break;case F.is(e):switch(e.params.action){case"graph":{let e;if(null==(e="wip"===this._context.mode?this._context.wip?.changes!=null?(0,w.kA)(g.SU,this._context.wip.changes.repository.path,{refType:"revision"}):void 0:null!=this._context.commit?(0,w.rd)(this._context.commit):void 0))return;(0,C.RS)("graph"===this.options.attachedTo?l.T.ShowInCommitGraphView:l.T.ShowInCommitGraph,{ref:e});break}case"more":this.showCommitActions();break;case"scm":(0,C.S4)("workbench.view.scm");break;case"sha":null!=this._context.commit&&(e.params.alt?(0,C.RS)(l.T.CopyMessageToClipboard,{message:this._context.commit.message}):(0,p.kk)(this._context.commit)?s.env.clipboard.writeText(this._context.commit.stashName):(0,C.RS)(l.T.CopyShaToClipboard,{sha:this._context.commit.sha}))}break;case Q.is(e):this.showCommitPicker();break;case V.is(e):this.showCommitSearch();break;case J.is(e):this.switchMode(e.params);break;case B.is(e):this.updatePinned(e.params.pin??!1,!0);break;case Y.is(e):this.navigateStack(e.params.direction);break;case K.is(e):this.updatePreferences(e.params);break;case eh.is(e):this.explainRequest(eh,e);break;case ed.is(e):this.generateRequest(ed,e);break;case j.is(e):this.stageFile(e.params);break;case G.is(e):this.unstageFile(e.params);break;case Z.is(e):this.createPatchFromWip(e.params);break;case et.is(e):this.fetch();break;case ei.is(e):this.publish();break;case en.is(e):this.push();break;case es.is(e):this.pull();break;case ea.is(e):this.switch();break;case W.is(e):this.suggestChanges(e.params);break;case ee.is(e):this.showCodeSuggestion(e.params.id);break;case X.is(e):this.setInReview(e.params.inReview,"inspect-overview");break;case eo.is(e):this.openPullRequestChanges();break;case er.is(e):this.openPullRequestComparison();break;case el.is(e):this.openPullRequestOnRemote();break;case ec.is(e):this.showPullRequestDetails()}}getEncodedEntityid(e=this._context.wip?.pullRequest){if(null==e)return;let t=(0,b.D)(e);if(null!=t)return n.EntityIdentifierUtils.encode(t)}async trackCreateCodeSuggestion(e,t){if(this._context.wip?.pullRequest==null)return;let i=this._context.wip.pullRequest.provider.id,n=await this.container.git.visibility(this._context.wip.repo.path);this.container.telemetry.sendEvent("codeSuggestionCreated",{provider:i,"repository.visibility":n,repoPrivacy:n,draftId:e.id,draftPrivacy:e.visibility,filesChanged:t,source:"reviewMode"},{source:"inspect-overview",detail:{reviewMode:!0}})}async suggestChanges(e){if(!await (0,k.G5)(this.container,"Code Suggestions are a Preview feature and require an account.",{source:"code-suggest",detail:"create"})||!await (0,k.l7)(this.container))return;let t=[],i=Object.entries(e.changesets),a=1===i.length,o=0;for(let[e,n]of i){if(!a&&!1===n.checked)continue;let e=this._context.wip.repo.id===n.repository.path?this._context.wip.repo:void 0;if(null==e)continue;let{checked:i}=n,s={to:g.SU,from:"HEAD"};"staged"===i&&(s={...s,to:g.id});let r=this.getEncodedEntityid();null!=r&&(n.files&&n.files.length>0&&("staged"===i?o+=n.files.filter(e=>!0===e.staged).length:o+=n.files.length),t.push({repository:e,revision:s,prEntityId:r}))}if(0!==t.length)try{let i=(0,b.D)(this._context.wip.pullRequest),a=n.EntityIdentifierUtils.encode(i),r={description:e.description,visibility:"provider_access",prEntityId:a},l=await this.container.drafts.createDraft("suggested_pr_change",e.title,t,r);(async function(){let e={title:"View Code Suggestions"},t={title:"Copy Link"},i=!1;for(;;){let n=await s.window.showInformationMessage(`Code Suggestion successfully created${i?"— link copied to the clipboard":""}`,e,t);if(n===t){s.env.clipboard.writeText(l.deepLinkUrl),i=!0;continue}n===e&&(0,v.X)({mode:"view",draft:l,source:"notification"});break}})(),this.setInReview(!1),this.trackCreateCodeSuggestion(l,o)}catch(e){s.window.showErrorMessage(`Unable to create draft: ${e.message}`)}}getRepoActionPath(){return"wip"===this._context.mode?this._context.wip?.repo.path:this._context.commit?.repoPath}fetch(){let e=this.getRepoActionPath();null!=e&&d.hd(e)}publish(){let e=this.getRepoActionPath();null!=e&&(0,C.wS)("git.publish",s.Uri.file(e))}push(){let e=this.getRepoActionPath();null!=e&&d.VC(e)}pull(){let e=this.getRepoActionPath();null!=e&&d.a$(e)}switch(){let e=this.getRepoActionPath();null!=e&&d.S_(e)}get pullRequestContext(){if("wip"===this.mode){if(this._context.wip?.pullRequest==null)return;return{repoPath:this._context.wip.repo.path,branch:this._context.wip.branch,pr:this._context.wip.pullRequest}}if(null!=this._context.pullRequest)return{repoPath:this._context.commit.repoPath,commit:this._context.commit,pr:this._context.pullRequest}}openPullRequestChanges(){if(null==this.pullRequestContext)return;let{repoPath:e,pr:t}=this.pullRequestContext;if(null==t.refs)return;let i=(0,f.tI)(e,t.refs);return(0,h.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}openPullRequestComparison(){if(null==this.pullRequestContext)return;let{repoPath:e,pr:t}=this.pullRequestContext;if(null==t.refs)return;let i=(0,f.tI)(e,t.refs);return this.container.searchAndCompareView.compare(i.repoPath,i.head,i.base)}async openPullRequestOnRemote(e){if(null==this.pullRequestContext)return;let{pr:{url:t}}=this.pullRequestContext;return(0,C.RS)(l.T.OpenPullRequestOnRemote,{pr:{url:t},clipboard:e})}async showPullRequestDetails(){if(null==this.pullRequestContext)return;let{pr:e,repoPath:t,branch:i,commit:n}=this.pullRequestContext;if(null!=e)return this.container.pullRequestView.showPullRequest(e,n??i??t)}onRefresh(e){if(!this._pinned){if("wip"===this.mode){let e=this._context.wip?.changes?.repository.uri;this.updateWipState(this.container.git.getBestRepositoryOrFirst(null!=e?s.Uri.parse(e):void 0))}else{let e=this._pendingContext?.commit??this.getBestCommitOrStash();this.updateCommit(e,{immediate:!1})}}}onReloaded(){this.notifyDidChangeState(!0)}onVisibilityChanged(e){if(this.ensureTrackers(),!e)return;let t=this._skipNextRefreshOnVisibilityChange;if(t&&(this._skipNextRefreshOnVisibilityChange=!1),this._bootstraping){if(this._bootstraping=!1,null==this._pendingContext)return;this.updateState()}else t||this.onRefresh(),this.updateState(!0)}onAnyConfigurationChanged(e){(_.H.changed(e,["defaultDateFormat","defaultDateStyle","views.commitDetails.files","views.commitDetails.avatars"])||_.H.changedCore(e,"workbench.tree.renderIndentGuides")||_.H.changedCore(e,"workbench.tree.indent"))&&(this.updatePendingContext({preferences:{...this._context.preferences,...this._pendingContext?.preferences,...this.getPreferences()}}),this.updateState()),null!=this._context.commit&&_.H.changed(e,["views.commitDetails.autolinks","views.commitDetails.pullRequests"])&&(this.updateCommit(this._context.commit,{force:!0}),this.updateState())}onSubscriptionChanged(e){this.updateCodeSuggestions(),this.updateHasAccount(e.current)}updateHasAccount(e){let t=null!=e.account;this._context.hasAccount!=t&&(this._context.hasAccount=t,this.host.notify(em,{hasAccount:t}))}onIntegrationConnectionStateChanged(e){if("jira"===e.key){let t="connected"===e.reason;this._context.hasConnectedJira!==t&&(this._context.hasConnectedJira=t,this.host.notify(eg,{hasConnectedJira:this._context.hasConnectedJira}))}}async getHasJiraConnection(e=!1){if(null!=this._context.hasConnectedJira&&!e)return this._context.hasConnectedJira;let t=await this.container.integrations.get(x.tp.Jira);return null==t?this._context.hasConnectedJira=!1:this._context.hasConnectedJira=t.maybeConnected??await t.isConnected(),this._context.hasConnectedJira}async getHasAccount(e=!1){return(null==this._context.hasAccount||e)&&(this._context.hasAccount=(await this.container.subscription.getSubscription())?.account!=null),this._context.hasAccount}getPreferences(){return{autolinksExpanded:this.container.storage.getWorkspace("views:commitDetails:autolinksExpanded")??!0,pullRequestExpanded:this.container.storage.getWorkspace("views:commitDetails:pullRequestExpanded")??!0,avatars:_.H.get("views.commitDetails.avatars"),dateFormat:_.H.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",dateStyle:_.H.get("defaultDateStyle")??"relative",files:_.H.get("views.commitDetails.files"),indentGuides:_.H.getCore("workbench.tree.renderIndentGuides")??"onHover",indent:_.H.getCore("workbench.tree.indent")}}onContextChanged(e){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(e)&&(this.updatePendingContext({orgSettings:this.getOrgSettings()}),this.updateState())}getOrgSettings(){return{ai:(0,S.SD)("gitlens:gk:organization:ai:enabled",!1),drafts:(0,S.SD)("gitlens:gk:organization:drafts:enabled",!1)}}onCommitSelected(e){if(null!=e.data&&("graph"!==this.options.attachedTo||"gitlens.views.graph"===e.source)&&("default"!==this.options.attachedTo||"gitlens.views.graph"!==e.source)){if("graph"===this.options.attachedTo){e.data.commit.ref===g.SU?"wip"!==this.mode?this.setMode("wip",this.container.git.getRepository(e.data.commit.repoPath)):e.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(e.data.commit.repoPath)):(this._pinned&&"passive"===e.data.interaction&&(this._commitStack.insert((0,w.rd)(e.data.commit)),this.updateNavigation()),"commit"!==this.mode&&this.setMode("commit",this.container.git.getRepository(e.data.commit.repoPath)),this._pinned&&"passive"===e.data.interaction||this.host.show(!1,{preserveFocus:e.data.preserveFocus},e.data));return}if("wip"===this.mode){e.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(e.data.commit.repoPath));return}this._pinned&&"passive"===e.data.interaction?(this._commitStack.insert((0,w.rd)(e.data.commit)),this.updateNavigation()):this.host.show(!1,{preserveFocus:e.data.preserveFocus},e.data)}}_lineTrackerDisposable;_selectionTrackerDisposable;ensureTrackers(){if(this._selectionTrackerDisposable?.dispose(),this._selectionTrackerDisposable=void 0,this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0,this.host.visible&&(this._selectionTrackerDisposable=this.container.events.on("commit:selected",this.onCommitSelected,this),!this._pinned&&"graph"!==this.options.attachedTo)){let{lineTracker:e}=this.container;this._lineTrackerDisposable=e.subscribe(this,e.onDidChangeActiveLines(this.onActiveEditorLinesChanged,this))}}get isLineTrackerSuspended(){return"graph"!==this.options.attachedTo&&null==this._lineTrackerDisposable}suspendLineTracker(){setTimeout(()=>{this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0},100)}createPatchFromWip(e){if(null==e.changes)return;let t={type:"wip",repository:{name:e.changes.repository.name,path:e.changes.repository.path,uri:e.changes.repository.uri},files:e.changes.files,revision:{to:g.SU,from:"HEAD"},checked:e.checked};(0,v.X)({mode:"create",create:{changes:[t]}})}showCodeSuggestion(e){let t=this._context.wip?.codeSuggestions?.find(t=>t.id===e);null!=t&&(0,v.X)({mode:"view",draft:t,source:"inspect"})}onActiveEditorLinesChanged(e){if(e.pending||null==e.editor||e.suspended)return;if("wip"===this.mode){let t=this.container.git.getBestRepositoryOrFirst(e.editor);this.updateWipState(t,!0);return}let t=e.selections?.[0]?.active,i=null!=t?this.container.lineTracker.getState(t)?.commit:void 0;this.updateCommit(i)}_wipSubscription;get mode(){return this._pendingContext?.mode??this._context.mode}async setMode(e,t){this.updatePendingContext({mode:e}),"commit"===e?this.updateState(!0):await this.updateWipState(t??this.container.git.getBestRepositoryOrFirst()),this.updateTitle()}updateTitle(){if("commit"===this.mode){if(null==this._context.commit)this.host.title=this.host.originalTitle;else{let e="Commit Details";"stash"===this._context.commit.refType?e="Stash Details":this._context.commit.isUncommitted&&(e="Uncommitted Changes"),this.host.title=`${this.host.originalTitle}: ${e}`}}else this.host.title=`${this.host.originalTitle}: Overview`}async explainRequest(e,t){let i;try{let e=await (await this.container.ai)?.explainCommit(this._context.commit,{source:"inspect",type:p.kk(this._context.commit)?"stash":"commit"},{progress:{location:{viewId:this.host.id}}});if(null==e)throw Error("Error retrieving content");i={summary:e}}catch(e){i={error:{message:e.message}}}this.host.respond(e,t,i)}async generateRequest(e,t){let i;let n=this._context.wip?.repo;if(!n){this.host.respond(e,t,{error:{message:"Unable to find changes"}});return}try{let e=await (await this.container.ai)?.generateDraftMessage(n,{source:"inspect",type:"suggested_pr_change"},{progress:{location:{viewId:this.host.id}}});if(null==e)throw Error("Error retrieving content");i=(0,a.extractDraftMessage)(e)}catch(e){i={error:{message:e.message}}}this.host.respond(e,t,i)}navigateStack(e){let t=this._commitStack.navigate(e);null!=t&&this.updateCommit(t,{immediate:!0,skipStack:!0})}_cancellationTokenSource=void 0;async getState(e){let t;if(null!=this._cancellationTokenSource&&(this._cancellationTokenSource.cancel(),this._cancellationTokenSource=void 0),null!=e.commit&&(t=await this.getDetailsModel(e.commit,e.formattedMessage),!e.richStateLoaded)){this._cancellationTokenSource=new s.CancellationTokenSource;let t=this._cancellationTokenSource.token;setTimeout(()=>{t.isCancellationRequested||this.updateRichState(e,t)},100)}let i=e.wip;if(null==i&&this._repositorySubscription){null==this._cancellationTokenSource&&(this._cancellationTokenSource=new s.CancellationTokenSource);let e=this._cancellationTokenSource.token;setTimeout(()=>{e.isCancellationRequested||this.updateWipState(this._repositorySubscription?.repo)},100)}return null==e.hasConnectedJira&&(e.hasConnectedJira=await this.getHasJiraConnection()),null==e.hasAccount&&(e.hasAccount=await this.getHasAccount()),(0,$.l)({...this.host.baseWebviewState,mode:e.mode,commit:t,navigationStack:e.navigationStack,pinned:e.pinned,preferences:e.preferences,includeRichContent:e.richStateLoaded,autolinkedIssues:e.autolinkedIssues?.map(m.Vz),pullRequest:null!=e.pullRequest?(0,f.pf)(e.pullRequest):void 0,wip:ex(i),orgSettings:e.orgSettings,inReview:e.inReview,hasConnectedJira:e.hasConnectedJira,hasAccount:e.hasAccount})}async updateWipState(e,t=!1){let i;if(null!=this._wipSubscription){let{repo:i,subscription:n}=this._wipSubscription;if(e?.path!==i.path)n.dispose(),this._wipSubscription=void 0;else if(t)return}let n=this.inReview;if(null!=e){null==this._wipSubscription&&(this._wipSubscription={repo:e,subscription:this.subscribeToRepositoryWip(e)});let t=await this.getWipChange(e);if(i={changes:t,repo:e,repositoryCount:this.container.git.openRepositoryCount},null!=t){let n=await this.getWipBranchDetails(e,t.branchName);null!=n&&(i.branch=n.branch,i.pullRequest=n.pullRequest,i.codeSuggestions=n.codeSuggestions)}if(i.pullRequest?.state!=="opened"&&(n=!1),this._shouldRefreshPullRequestDetails&&null!=i.pullRequest&&("launchpad"===this._context.source||this._pendingContext?.source==="launchpad")&&(this.container.pullRequestView.showPullRequest(i.pullRequest,i.branch??e.path),this._shouldRefreshPullRequestDetails=!1),null==this._pendingContext&&await this.host.notify(ep,(0,$.l)({wip:ex(i),inReview:n}))){this._context.wip=i,this._context.inReview=n;return}}this.updatePendingContext({wip:i,inReview:n}),this.updateState(!0)}async getWipBranchDetails(e,t){let i=await e.getBranch(t);if(null==i)return;if("commit"===this.mode)return{branch:i,pullRequest:void 0,codeSuggestions:[]};let n=await i.getAssociatedPullRequest({expiryOverride:3e5}),s=[];if(null!=n){let t=await this.getCodeSuggestions(n,e);t.length&&(s=t)}return{branch:i,pullRequest:n,codeSuggestions:s}}async canAccessDrafts(){return await this.getHasAccount()!==!1&&(0,S.SD)("gitlens:gk:organization:drafts:enabled",!1)}async getCodeSuggestions(e,t){if(!await this.canAccessDrafts())return[];let i=await this.container.drafts.getCodeSuggestions(e,t);for(let e of i){if(null!=e.author.avatarUri||null==e.organizationId)continue;let t=e.author.email;if(null==t){let i=await this.container.organizations.getMemberById(e.author.id,e.organizationId);t=i?.email}null!=t&&(e.author.avatarUri=(0,r.m_)(t))}return i}async updateCodeSuggestions(){if("wip"!==this.mode||this._context.wip?.pullRequest==null)return;let e=this._context.wip,{pullRequest:t,repo:i}=e;if(e.codeSuggestions=await this.getCodeSuggestions(t,i),null==this._pendingContext&&await this.host.notify(ep,(0,$.l)({wip:ex(e)}))){this._context.wip=e;return}this.updatePendingContext({wip:e}),this.updateState(!0)}async updateRichState(e,t){let{commit:i}=e;if(null==i)return;let n=await this.container.git.getBestRemoteWithIntegration(i.repoPath);if(t.isCancellationRequested)return;let[s,a]=n?.provider!=null?await Promise.allSettled([_.H.get("views.commitDetails.autolinks.enabled")&&_.H.get("views.commitDetails.autolinks.enhanced")?(0,A.zu)(i.getEnrichedAutolinks(n)):void 0,_.H.get("views.commitDetails.pullRequests.enabled")?i.getAssociatedPullRequest(n):void 0]):[];if(t.isCancellationRequested)return;let o=A.Ro(s)?.value,r=(0,A.Ro)(a),l=this.getFormattedMessage(i,n,o);this.updatePendingContext({richStateLoaded:!0,formattedMessage:l,autolinkedIssues:null!=o?[...(0,T.x1)(o.values(),([e])=>e?.value)]:void 0,pullRequest:r}),this.updateState()}_repositorySubscription;async updateCommit(e,t){let i;if(!t?.force&&this._context.commit?.sha===e?.ref)return;if((0,p.WM)(e))i=e;else if(null!=e){if("stash"===e.refType){let t=await this.container.git.getStash(e.repoPath);i=t?.commits.get(e.ref)}else i=await this.container.git.getCommit(e.repoPath,e.ref)}let n=this._pendingContext?.wip??this._context.wip;if(null!=this._repositorySubscription){let{repo:e,subscription:t}=this._repositorySubscription;i?.repoPath!==e.path&&(t.dispose(),this._repositorySubscription=void 0,n=void 0)}if(null==this._repositorySubscription&&null!=i){let e=await this.container.git.getOrOpenRepository(i.repoPath);null!=e&&(this._repositorySubscription={repo:e,subscription:this.subscribeToRepositoryWip(e)},"wip"===this.mode?this.updateWipState(e):n=void 0)}this.updatePendingContext({commit:i,richStateLoaded:!!i?.isUncommitted||(null!=i?!S.SD("gitlens:repos:withHostingIntegrationsConnected")?.includes(i.repoPath):!(0,S.SD)("gitlens:repos:withHostingIntegrationsConnected")),formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:n},t?.force),t?.pinned!=null&&this.updatePinned(t?.pinned),this.isLineTrackerSuspended&&this.ensureTrackers(),null!=i&&(t?.skipStack||this._commitStack.add((0,w.rd)(i)),this.updateNavigation()),this.updateState(t?.immediate??!0),this.updateTitle()}subscribeToRepositoryWip(e){return s.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(()=>this.onWipChanged(e)),e.onDidChange(t=>{t.changed(y.Z_.Index,y.Ti.Any)&&this.onWipChanged(e)}))}onWipChanged(e){this.updateWipState(e)}async getWipChange(e){let t=await this.container.git.getStatusForRepo(e.path);if(null==t)return;let i=[];for(let e of t.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};i.push(t),e.staged&&e.wip&&i.push({...t,staged:!1})}return{repository:{name:e.name,path:e.path,uri:e.uri.toString()},branchName:t.branch,files:i}}updatePinned(e,t){e!==this._context.pinned&&(this._pinned=e,this.ensureTrackers(),this.updatePendingContext({pinned:e}),this.updateState(t))}updatePreferences(e){if(this._context.preferences?.autolinksExpanded===e.autolinksExpanded&&this._context.preferences?.pullRequestExpanded===e.pullRequestExpanded&&this._context.preferences?.files?.compact===e.files?.compact&&this._context.preferences?.files?.icon===e.files?.icon&&this._context.preferences?.files?.layout===e.files?.layout&&this._context.preferences?.files?.threshold===e.files?.threshold)return;let t={...this._context.preferences,...this._pendingContext?.preferences};null!=e.autolinksExpanded&&this._context.preferences?.autolinksExpanded!==e.autolinksExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:autolinksExpanded",e.autolinksExpanded),t.autolinksExpanded=e.autolinksExpanded),null!=e.pullRequestExpanded&&this._context.preferences?.pullRequestExpanded!==e.pullRequestExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:pullRequestExpanded",e.pullRequestExpanded),t.pullRequestExpanded=e.pullRequestExpanded),null!=e.files&&(this._context.preferences?.files?.compact!==e.files?.compact&&_.H.updateEffective("views.commitDetails.files.compact",e.files?.compact),this._context.preferences?.files?.icon!==e.files?.icon&&_.H.updateEffective("views.commitDetails.files.icon",e.files?.icon),this._context.preferences?.files?.layout!==e.files?.layout&&_.H.updateEffective("views.commitDetails.files.layout",e.files?.layout),this._context.preferences?.files?.threshold!==e.files?.threshold&&_.H.updateEffective("views.commitDetails.files.threshold",e.files?.threshold),t.files=e.files),this.updatePendingContext({preferences:t}),this.updateState()}updatePendingContext(e,t=!1){let[i,n]=(0,q.ql)(this._context,this._pendingContext,e,t);return i&&(this._pendingContext=n),i}_notifyDidChangeStateDebounced=void 0;updateState(e=!1){if(e){this.notifyDidChangeState();return}null==this._notifyDidChangeStateDebounced&&(this._notifyDidChangeStateDebounced=(0,R.sg)(this.notifyDidChangeState.bind(this),500)),this._notifyDidChangeStateDebounced()}updateNavigation(){let e=this._commitStack.get(this._commitStack.position-1)?.ref;null!=e&&(e=(0,w.pV)(e)),this.updatePendingContext({navigationStack:{count:this._commitStack.count,position:this._commitStack.position,hint:e}}),this.updateState()}async setInReview(e,t){this.inReview!==e&&(null==this._pendingContext&&await this.host.notify(ef,{inReview:e})&&(this._context.inReview=e),this.updatePendingContext({inReview:e}),this.updateState(!0),e&&this.trackOpenReviewMode(t))}async notifyDidChangeState(e=!1){let t;let i=(0,D.dQ)();return this._notifyDidChangeStateDebounced?.cancel(),(!!e||null!=this._pendingContext)&&(null!=this._pendingContext?(t={...this._context,...this._pendingContext},this._context=t,this._pendingContext=void 0):t=this._context,s.window.withProgress({location:{viewId:this.host.id}},async()=>{try{await this.host.notify(eu,{state:await this.getState(t)})}catch(e){M.Vy.error(i,e)}}))}getBestCommitOrStash(){let e;if(!this._pinned){if("graph"!==this.options.attachedTo&&null!=s.window.activeTextEditor){let{lineTracker:t}=this.container,i=t.selections?.[0].active;null!=i&&(e=t.getState(i)?.commit)}else if(null==(e=this._pendingContext?.commit)){let t=this.container.events.getCachedEventArgs("commit:selected");e=t?.commit}return e}}async getDetailsModel(e,t){let[i,n,s]=await Promise.allSettled([e.hasFullDetails()?e:e.ensureFullDetails().then(()=>e),e.author.getAvatarUri(e,{size:32}),this.container.git.getBestRemoteWithIntegration(e.repoPath,{includeDisconnected:!0})]);e=(0,A.Ro)(i,e);let a=(0,A.Ro)(n),r=(0,A.Ro)(s);null==t&&(t=this.getFormattedMessage(e,r));let l=null!=e.message?await this.container.autolinks.getAutolinks(e.message,r):void 0;return{repoPath:e.repoPath,sha:e.sha,shortSha:e.shortSha,author:{...e.author,avatar:a?.toString(!0)},message:t,parents:e.parents,stashNumber:"stash"===e.refType?e.number:void 0,files:e.files,stats:e.stats,autolinks:null!=l?[...(0,T.Tj)(l.values(),o.U8)]:void 0}}getFormattedMessage(e,t,i){let n=u.c.fromTemplate("${message}",e),s=n.indexOf("\n");return(-1!==s&&(n=`${n.substring(0,s)}\0
\0${n.substring(s+1)}`),_.H.get("views.commitDetails.autolinks.enabled"))?this.container.autolinks.linkify(n,"html",null!=t?[t]:void 0,i):n}async getFileCommitFromParams(e){let t;if("wip"===this.mode){let e=this._context.wip?.changes?.repository.uri;if(null==e)return;t=await this.container.git.getCommit(s.Uri.parse(e),g.SU)}else t=this._context.commit;return null!=(t=await t?.getCommitForFile(e.path,e.staged))?[t,t.file]:void 0}showCommitPicker(){(0,c.b)({command:"log",state:{reference:"HEAD",repo:this._context.commit?.repoPath,openPickInView:!0}})}showCommitSearch(){(0,c.b)({command:"search",state:{openPickInView:!0}})}showCommitActions(){null==this._context.commit||this._context.commit.isUncommitted||(0,h.G4)(this._context.commit)}async showFileActions(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,n]=t;this.suspendLineTracker(),(0,h.G4)(i,n)}switchMode(e){let t;if(this.mode!==e.mode){if("wip"===e.mode){let{repoPath:i}=e;if(null==i){if(null==(t=this.container.git.getBestRepositoryOrFirst()))return;i=t.path}else t=this.container.git.getRepository(i)}this.setMode(e.mode,t)}}async openFileComparisonWithWorking(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,n]=t;this.suspendLineTracker(),(0,h.DD)(n,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(e)})}async openFileComparisonWithPrevious(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,n]=t;this.suspendLineTracker(),(0,h.eX)(n,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(e)}),this.container.events.fire("file:selected",{uri:n.uri},{source:this.host.id})}async openFile(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,n]=t;this.suspendLineTracker(),(0,h.Tq)(n,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(e)})}async openFileOnRemote(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,n]=t;(0,h.gV)(n,i)}async stageFile(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,n]=t;await this.container.git.stageFile(i.repoPath,n.path)}async unstageFile(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,n]=t;await this.container.git.unstageFile(i.repoPath,n.path)}getShowOptions(e){return e.showOptions}};function ex(e){if(null!=e)return{changes:e.changes,repositoryCount:e.repositoryCount,branch:function(e){if(null!=e)return{name:e.name,repoPath:e.repoPath,upstream:e.upstream,tracking:{ahead:e.state.ahead,behind:e.state.behind}}}(e.branch),repo:{uri:e.repo.uri.toString(),name:e.repo.name,path:e.repo.path},pullRequest:null!=e.pullRequest?(0,f.pf)(e.pullRequest):void 0,codeSuggestions:e.codeSuggestions?.map(e=>(0,$.l)({...e,changesets:void 0}))}}ev([(0,P.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"getState",1),ev([(0,P.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateWipState",1),ev([(0,P.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateRichState",1)}};